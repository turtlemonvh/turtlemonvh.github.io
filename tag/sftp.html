<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Systems Doing - sftp</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Systems Doing  <strong>Looking for beauty in the complex and the simple.</strong></a></h1>
                <nav><ul>
                    <li><a href="/pages/home.html">Home</a></li>
                    <li><a href="/pages/projects.html">Projects</a></li>
                    <li><a href="/category/articles.html">Articles</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/quick-and-dirty-kubernetes.html">Quick and dirty kubernetes</a></h1>
<footer class="post-info">
        <abbr class="published" title="2017-10-27T18:47:00-04:00">
                Published: Fri 27 October 2017
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/turtlemonvh.html">turtlemonvh</a>
        </address>
<p>In <a href="/category/articles.html">Articles</a>.</p>
<p>tags: <a href="/tag/kubernetes.html">kubernetes</a> <a href="/tag/docker.html">docker</a> <a href="/tag/sftp.html">sftp</a> </p>
</footer><!-- /.post-info --><h1>The Problem</h1>
<p>As part of our analytics solution at Ionic, my team was working on a system to push files to customer owned endpoints.  We wanted to do a quick validation that pushed to a server outside our network was working.</p>
<p>We already had a test environment running locally with <a href="https://github.com/atmoz/sftp">an sftp docker image</a>, and since I didn't already have a public server sitting around for running an sftp server, I decided this was a great opportunity to play around with <a href="https://cloud.google.com/container-engine/">Google Cloud's Container service</a> and <a href="https://kubernetes.io/">Kubernetes</a> to spin up a quick and dirty sftp server to try to push data to.</p>
<h1>Web console to cli</h1>
<p>I started out trying to do everything through the web console.  I went to the Container Engine section of the test project I already had set up in GCP and created a test cluster named <code>sftp</code>.  I created it with size 1 (only 1 backing host) to keep the cost low, and because having a single sftp server is easier to reason about for testing purposes (i.e. there is only 1 place your data will be).  There are a lot of other options for a cluster, but I kept most of them set to their defaults.</p>
<p>From there it wasn't very clear how to run a container from the web ui, so I had to dig into command line tools.  With those, I started here: <a href="https://cloud.google.com/sdk/docs/quickstart-linux">https://cloud.google.com/sdk/docs/quickstart-linux</a>.  I installed the sdk into a Centos 7 vagrant box that my team uses for most of our development.</p>
<div class="highlight"><pre><span></span><span class="err">#</span><span class="x"> Download, extract, install, init</span>
<span class="x">wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-177.0.0-linux-x86_64.tar.gz</span>
<span class="x">tar xzvf google-cloud-sdk-177.0.0-linux-x86_64.tar.gz</span>
<span class="x">./google-cloud-sdk/install.sh</span>

<span class="err">#</span><span class="x"> Move it to a better place than `/tmp` since I&#39;m going to be sticking this on my path</span>
<span class="x">sudo mv google-cloud-sdk /opt/</span>
<span class="x">export PATH=</span><span class="p">$</span><span class="nv">PATH</span><span class="x">:/opt/google-cloud-sdk/bin</span>

<span class="err">#</span><span class="x"> Init</span>
<span class="x">gcloud init</span>

<span class="err">#</span><span class="x"> Get credentials for the cluster</span>
<span class="err">#</span><span class="x"> This is pretty cool - it gives you a url to visit in your browser, redirects you to an Oauth authorization page, and finally gives you a token to paste back into your console.</span>
<span class="err">#</span><span class="x"> I replaced by project id with XXXX.</span>
<span class="x">gcloud container clusters get-credentials sftp --zone us-central1-a --project ionictest-XXXX</span>
</pre></div>


<h1>The first hiccup: install path</h1>
<p>This was all working pretty well, but then I ran into issues when I ran <code>gcloud components install kubectl</code>.  There were permission issues because <code>gcloud</code> tries to write a scratch directory at the same level as its installation directory (i.e. in <code>/opt</code> instead of in <code>/opt/google-cloud-sdk</code>.)  This was a strange choice, since it meant that I had to nest the installation another level deeper.</p>
<div class="highlight"><pre><span></span><span class="err">#</span><span class="x"> Nesting nesting</span>
<span class="x">sudo mkdir -p /opt/google</span>
<span class="x">sudo chown -R vagrant:vagrant /opt/google</span>
<span class="x">sudo mv /opt/google-cloud-sdk /opt/google</span>

<span class="err">#</span><span class="x"> Fix path</span>
<span class="err">#</span><span class="x"> Really this was more manual since I removed the old bin path and also updated ~/.bashrc</span>
<span class="x">export PATH=</span><span class="p">$</span><span class="nv">PATH</span><span class="x">:/opt/google/google-cloud-sdk/bin</span>

<span class="err">#</span><span class="x"> Now installation works</span>
<span class="x">gcloud components install kubectl</span>
</pre></div>


<p>At this point the path was bjorked.  When I tried to run <code>kubectl run</code> I got this mysterious error</p>
<div class="highlight"><pre><span></span><span class="n">error</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">discover</span> <span class="n">supported</span> <span class="n">resources</span><span class="o">:</span> <span class="n">Get</span> <span class="n">https</span><span class="o">://</span><span class="n">XX</span><span class="o">.</span><span class="na">XX</span><span class="o">.</span><span class="na">XX</span><span class="o">.</span><span class="na">XX</span><span class="sr">/api: error executing access token command &quot;/opt/google-cloud-sdk/bin/gcloud config config-helper --format=json&quot;: err=fork/exec /opt/google-cloud-sdk/bin/g</span><span class="n">cloud</span><span class="o">:</span> <span class="n">no</span> <span class="n">such</span> <span class="n">file</span> <span class="n">or</span> <span class="n">directory</span> <span class="n">output</span><span class="o">=</span>
</pre></div>


<p>Notice the path is pointing to the old installation location.  I reset my PATH, logged out of the vm and logged back in, and re-ran <code>gcloud components install kubectl</code>, none of which worked.  Then I re-ran the <code>gcloud container clusters get-credentials</code>, which worked.  So I guess the path to the binary is stored somewhere in the credentials config?  I'm not sure.  This article is called "quick and dirty" for a reason.</p>
<p>Now to launch containers.</p>
<div class="highlight"><pre><span></span>kubectl run sftp --image=atmoz/sftp --port 22
kubectl expose deployment sftp --type=LoadBalancer --port 22 --target-port 22
</pre></div>


<p>Alright - we're running!</p>
<h1>The second hiccup: container arguments</h1>
<p>Well, almost.  When I checked the Google Container Engine dashboard I saw the the containers has the status <code>CrashLoopBackoff</code>, which didn't sound good.  I dug into the kubectl cli a bit more and found some useful commands.</p>
<div class="highlight"><pre><span></span># List items
kubectl get pods
kubectl get services
kubectl get deployments

# Clear out items (very helpful when testing)
kubectl delete pod sftp-2557270963-pc8q8
kubectl delete service sftp
kubectl delete deployment sftp
</pre></div>


<p>I leave it to the kubernetes docs to define what the things are in depth, but in brief the pods are containers and services and deployments are higher level management concepts to work with containers.  For the point of this article the most important take aways are this</p>
<ul>
<li>If you delete a pod, it will come back.</li>
<li>If you want to stop something from running and start over, delete the service and the deployment. The pods will go away with those.</li>
</ul>
<p>So - now we have pods deployed, but crashing.  The missing link here was the difference between kubernetes commands and docker entrypoints.</p>
<div class="highlight"><pre><span></span># What our docker compose looks like for running locally
# Use the default entrypoint, override the command
version: &#39;2&#39;
services:
  sftp:
    image: atmoz/sftp
    command: username:password:::export

# What we had to do in kubectl
# Use the default command, send an argument
kubectl run sftp --image=atmoz/sftp --port=22 -- &quot;username:password:::export&quot;
</pre></div>


<h1>Final steps and success</h1>
<p>Once that was updated, I just had to expose the services again (<code>kubectl expose deployment sftp --type=LoadBalancer --port 22 --target-port 22</code>).  I also had to wait for the service to come up.  You can check this via <code>kubectl get services</code> and waiting until the <code>EXTERNAL-IP</code> field changes from "pending" to a real ip.  Once that was ready, and I could sftp in!</p>
<div class="highlight"><pre><span></span>[vagrant@localhost ~]$ sftp username@XX.XX.XX.XX
username@XX.XX.XX.XX&#39;s password:
Connected to XX.XX.XX.XX.
sftp&gt; ls export/
export/testfile.json
</pre></div>


<p>I hope that was helpful.  I have been using docker daily for a few years now, but this is my first time playing with kubernetes.  If I did something stupid, let me know!  You can find me <a href="https://twitter.com/turtlemonvh">on twitter</a>.</p><p>There are <a href="/quick-and-dirty-kubernetes.html#disqus_thread">comments</a>.</p>                </article>
            </aside><!-- /#featured -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>blogroll</h2>
                        <ul>
                            <li><a href="https://www.ionic.com/blog/">Ionic blog</a></li>
                            <li><a href="http://turtle-philosophy.blogspot.com/">My old blog</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="https://twitter.com/turtlemonvh">twitter</a></li>
                            <li><a href="https://about.me/turtlemonvh">about.me</a></li>
                            <li><a href="https://github.com/turtlemonvh">github</a></li>
                            <li><a href="https://www.linkedin.com/in/vanheetm">linkedin</a></li>
                            <li><a href="https://bitbucket.org/turtlemonvh/">bitbucket</a></li>
                            <li><a href="http://stackoverflow.com/users/790075/turtlemonvh">stackoverflow</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

<script type="text/javascript">
    var disqus_shortname = 'turtlemonvh-github-io';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>